/**@
 * Checks if the given value is defined and has a value other than null.
 *
 * @param value the value to check
 * @returns {boolean} true if the given value is defined and its value is not null.
 */
sirius.isDefined = function (value) {
    return typeof value !== 'undefined' && value !== null && value !== undefined;
}

/**@
 * Checks if the given value is empty or null.
 *
 * @param value the value to check
 * @returns {boolean} true if the given value is null, undefined, an empty string or an empty array.
 */
sirius.isEmpty = function (value) {
    if (Array.isArray(value) && value.length === 0) {
        return true;
    }

    if (sirius.isDefined(value) && typeof value === 'object') {
        return isEmptyObject(value);
    }

    return !sirius.isDefined(value) || value === '';
}

/**@
 * Checks if the given object is empty.
 * @param obj the object to check
 * @returns {boolean} true if the given object is empty, false otherwise
 */
function isEmptyObject (obj) {
    for (const prop in obj) {
        if (Object.hasOwn(obj, prop)) {
            return false;
        }
    }

    return true;
}

/**@
 * Checks if the given value is non-empty.
 * @param value the value to check
 * @returns {boolean} the inverse of "isEmpty"
 */
sirius.isFilled = function (value) {
    return !sirius.isEmpty(value);
}

/**@
 * Executes the given callback once the DOM is completely loaded.
 *
 * @param callback the callback to execute once the DOM is completely ready
 */
sirius.ready = function (callback) {
    // Add as listener in case DOM is loading...
    document.addEventListener("DOMContentLoaded", callback);
    // Call manually is we're late...
    if (document.readyState === "interactive" || document.readyState === "complete") {
        callback();
    }
}

/**@
 * Checks if the given element is a DOM element.
 *
 * @param obj the element to check
 * @returns {boolean} true if the given element is a real DOM element, false otherwise
 */
sirius.isElement = function (obj) {
    try {
        //Using W3 DOM2 (works for FF, Opera and Chrome)
        return obj instanceof HTMLElement;
    } catch (e) {
        //Browsers not supporting W3 DOM2 don't have HTMLElement and
        //an exception is thrown and we end up here. Testing some
        //properties that all elements have (works on IE7)
        return (typeof obj === "object") &&
            (obj.nodeType === 1) && (typeof obj.style === "object") &&
            (typeof obj.ownerDocument === "object");
    }
}

/**@
 * Searches for the given element using document.querySelector.
 *
 * However, if query is already a DOM element, it is simply returned.
 *
 * @param query either a selector or a DOM element
 * @returns {*} the matching DOM element (or the given one, if query was a DOM element in the first place).
 */
sirius.querySelector = function (query) {
    if (query == null) {
        return null;
    } else if (sirius.isElement(query)) {
        return query;
    } else {
        return document.querySelector(query);
    }
}

/**@
 * Clears the "display" property of the given element to make it visible.
 * It is expected to be 'display: none' before.
 */
sirius.show = function (selectorOrElement) {
    const _element = this.querySelector(selectorOrElement);
    if (_element != null) {
        _element.style.display = '';
    }
}

/**@
 * Sets the "display" property of the given element to 'none' to make it invisible.
 */
sirius.hide = function (selectorOrElement) {
    const _element = this.querySelector(selectorOrElement);
    if (_element != null) {
        _element.style.display = 'none';
    }
}

/**@
 * Tries to find the parent node of the given type.
 *
 * @param _node the node to search in
 * @param type the element type to search for (Note that the type is UPPERCASE like 'FORM').
 * @returns {null|*} the first matching element (nearest parent) or null if none is found
 */
sirius.findParentOfType = function (_node, type) {
    let _parent = _node.parentNode;
    while (_parent != null) {
        if (_parent.nodeName === type) {
            return _parent;
        } else {
            _parent = _parent.parentNode;
        }
    }

    return null;
}

/**@
 * Invokes the given listener if enter is pressed in the given input field.
 *
 * @param _node the node to attach the listener on
 * @param listener the listener to attach
 */
sirius.addEnterListener = function (_node, listener) {
    _node.addEventListener('keydown', function (event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            listener(event);
        }
    });
}

/**@
 * Calls the given URL, sends the given params and retrieves the resulting JSON.
 *
 * @param url the URL to invoke
 * @param params the parameters to send as query string (as a GET request is generated)
 * @returns {Promise<any>} the received JSON data
 */
sirius.getJSON = function (url, params) {
    if (!url.endsWith('?')) {
        url = url + '?';
    }
    Object.keys(params).forEach(function (key) {
        if (!url.endsWith('?')) {
            url += '&';
        }
        url += key + '=' + encodeURIComponent(params[key]);
    });

    return fetch(url, {
        method: "get"
    }).then(function (response) {
        return response.json();
    });
}

/**@
 * Calls the given URL, posts the given params and retrieves the resulting JSON.
 *
 * @param url the URL to invoke
 * @param params the parameters to send POST data (parameters with 'undefined' values are not sent to the server)
 * @returns {Promise<any>} the received JSON data
 */
sirius.postJSON = function (url, params) {
    let formData = new FormData();
    Object.keys(params).forEach(function (key) {
        const value = params[key];
        if (Array.isArray(value)) {
            value.forEach(function (entry) {
                formData.append(key, entry);
            });
        } else if (sirius.isDefined(value)) {
            formData.append(key, value);
        }
    });

    return fetch(url, {
        method: "post",
        body: formData
    }).then(function (response) {
        return response.json();
    });
}

/**@
 * Throttles a javascript function by calling it only every x milliseconds.
 * <p>
 * The throttled function is called once immediately, and then every x milliseconds.
 *
 * @param fn        the function to be throttled
 * @param threshold the time delaying each function call (in milliseconds).
 */
sirius.throttle = function (fn, threshold) {
    let last;
    let deferTimer;

    return function () {
        const context = this;
        const now = Date.now();
        const args = arguments;

        if (last && now < last + threshold) {
            // hold on to it
            clearTimeout(deferTimer);

            deferTimer = setTimeout(function () {
                last = now;
                fn.apply(context, args);
            }, threshold + last - now);
        } else {
            last = now;
            fn.apply(context, args);
        }
    };
}

/**@
 * Adds an event listener that triggers exactly once per element when it becomes visible or is about to become visible.
 * <p>
 * The event will trigger once an element comes within a certain distance to the viewport. By default the vertical and
 * horizontal distances are equal to the element's height and width respectively. This distance can be increased by
 * specifying a value greater than 1 as the distanceFactor.
 *
 * @param selector       the selector the elements need to match
 * @param listener       the function to call for every element
 * @param distanceFactor the optional distance factor to control how far away the event will trigger, 1 by default
 */
sirius.addElementVisibleListener = function (selector, listener, distanceFactor) {
    const isElementNowOrSoonVisible = function (element) {
        const factor = distanceFactor || 1;
        const rect = element.getBoundingClientRect();

        const verticalMargin = rect.height * factor;
        const horizontalMargin = rect.width * factor;
        const clientHeight = document.documentElement.clientHeight;
        const clientWidth = document.documentElement.clientWidth;

        const visibleVertically = (rect.bottom + verticalMargin) >= 0 && (rect.top - verticalMargin) < clientHeight;
        const visibleHorizontally = (rect.left + horizontalMargin) >= 0 && (rect.right - horizontalMargin) < clientWidth;

        return visibleVertically && visibleHorizontally;
    };

    const handleVisibleElements = function () {
        const elements = document.querySelectorAll(selector);

        for (let i = 0; i < elements.length; i++) {
            let element = elements[i];

            if (!element.getAttribute('data-scroll-event-handled') && isElementNowOrSoonVisible(element)) {
                element.setAttribute('data-scroll-event-handled', true);

                listener(element);
            }
        }
    };

    // Check after the page is loaded and when resizing or scrolling the page
    sirius.ready(handleVisibleElements);
    window.addEventListener('resize', sirius.throttle(handleVisibleElements, 20));
    document.addEventListener('scroll', sirius.throttle(handleVisibleElements, 20), {
        capture: true
    });

    // Listen for DOM changes that might influence the position of other elements
    const observer = new MutationObserver(sirius.throttle(handleVisibleElements, 20));

    observer.observe(document, {
        childList: true,
        subtree: true,
        attributes: true,
        characterData: true
    });
}

/**@
 * Transforms a string from snake-case to camel-case.
 *
 * @param str the string to transform
 * @returns {*} the string in camel-case
 */
sirius.camelize = function (str) {
    return str.replace(/[\-_](\w)/g, function (match) {
        return match.charAt(1).toUpperCase();
    });
};

/**@
 * Submits the given form using
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/requestSubmit HTMLFormElement.requestSubmit}
 * to trigger its submit event as well as constraint validation.
 * Falls back to silently submitting the form via {@link HTMLFormElement.submit} in unsupported browsers.
 *
 * @param form the form to submit
 */
sirius.requestSubmitForm = function (form) {
    if (form != null) {
        if (form.requestSubmit) {
            form.requestSubmit();
        } else {
            form.submit();
        }
    }
}

/**@
 * Tries to embed SVG img-tags into the DOM.
 *
 * @param _container the container in which to look for img-tags
 * @param selector   the selector the img-tags need to match
 */
sirius.embedSvgImages = function (_container, selector) {
    const elements = _container.querySelectorAll(selector + ':not(.svg-embed-handled)');

    for (let i = 0; i < elements.length; i++) {
        const _img = elements[i];
        const src = _img.getAttribute('src') || '';

        _img.classList.add('svg-embed-handled');

        if (src.includes('.svg?') || src.includes('.svg#') || src.endsWith('.svg')) {
            fetch(src, {
                method: "GET"
            }).then(function (response) {
                return response.text();
            }).then(function (data) {
                const parser = new DOMParser();
                const svg = parser.parseFromString(data, "image/svg+xml").documentElement;

                if (svg.nodeName === 'svg') {
                    // Classes need to be set via setAttribute for SVGElement
                    svg.setAttribute('class', _img.className);

                    _img.parentNode.replaceChild(svg, _img);
                }
            });
        }
    }
}

/**@
 * Actually makes the browser re-execute script nodes within a given DOM tree.
 *
 * This is mostly relevant, if a DOM subtree has been generated e.g. via Mustache. If script nodes are
 * injected into the DOM, these are ignored by the browser as per HTML 5 spec. Calling this function on
 * the container with the updated HTML will clone the script nodes so that they are actually invoked properly.
 *
 * @param _container the container to re-invoke all inner script tags
 */
sirius.executeEmbeddedScripts = function (_container) {
    function nodeScriptReplace(_node) {
        if (_node.tagName === 'SCRIPT') {
            _node.parentNode.replaceChild(nodeScriptClone(_node), _node);
        } else {
            for (let i = 0; i < _node.childNodes.length; i++) {
                nodeScriptReplace(_node.childNodes[i]);
            }
        }

        return _node;
    }

    function nodeScriptClone(_node) {
        const _clonedScriptNode = document.createElement("script");
        _clonedScriptNode.text = _node.innerHTML;

        for (let i = 0; i < _node.attributes.length; i++) {
            const attribute = _node.attributes[i];
            _clonedScriptNode.setAttribute(attribute.name, attribute.value);
        }
        return _clonedScriptNode;
    }

    nodeScriptReplace(_container);
}
/**@
 * Warns the user when leaving the current site.
 *
 * This should mainly be used to prevent data loss - for example if the user has unsaved changes in a form, or a file
 * is uploading. You should provide a function which is called when the user unloads the site, and the user is only
 * warned, if the function returns true. This function should check if the user actually has unsaved data, or a file is
 * uploading, for example. This method can be called multiple times with different callbacks and if any one of them
 * return true, the user is warned. If no method is provided, the user is always warned.
 *
 * @param shouldWarnCallback the function to call on unload to determine if to warn
 */
sirius.warnOnUnload = function (shouldWarnCallback) {
    window.addEventListener("beforeunload", function (event) {
        if (!(shouldWarnCallback instanceof Function) || shouldWarnCallback()) {
            event.preventDefault();
            return event.returnValue = '';
        }
    });
}

/**@
 * Allows to dispatch a custom event of the given type while handling different browser environments.
 *
 * @param {string} eventType the type of event to trigger
 * @param {HTMLElement} [_eventTarget] allows to specify the DOM element to dispatch the event from (default is `document`)
 * @param {Object} [eventDetail] allows to specify an object to be passed as event details to the receiver
 */
sirius.dispatchEvent = function (eventType, _eventTarget, eventDetail) {
    const _effectiveTarget = _eventTarget || document;
    const detail = eventDetail || this;

    if (typeof (CustomEvent) === 'function') {
        _effectiveTarget.dispatchEvent(new CustomEvent(eventType, {detail: detail}));
    } else {
        const event = document.createEvent('Event');
        event.initEvent(eventType, true, true);
        event.detail = detail;
        _effectiveTarget.dispatchEvent(event);
    }
}

/**@
 * Resets the viewport zoom of mobile browsers applied by pinch-to-zoom gestures as these are not accounted for in the
 * window size methods resulting in only partially visible contents when zoomed in.
 */
sirius.resetMobileZoom = function () {
    const scaleBlockingViewportContent = 'width=device-width, minimum-scale=1.0, maximum-scale=1.0, initial-scale=1.0';
    let _viewportMeta = document.querySelector('meta[name="viewport"]');

    if (_viewportMeta) {
        // We alter the viewport content and reset it to the original settings
        // after the browser had time to reset the viewport zoom
        const origViewportContent = _viewportMeta.getAttribute('content');
        _viewportMeta.setAttribute('content', scaleBlockingViewportContent);
        setTimeout(function () {
            _viewportMeta.setAttribute('content', origViewportContent);
        }, 100);
    } else {
        // When no viewport meta tag exists we create one, set the content that resets the viewport zoom and remove it
        _viewportMeta = document.createElement("meta");
        _viewportMeta.setAttribute("name", "viewport");
        document.head.appendChild(_viewportMeta);

        _viewportMeta.setAttribute('content', scaleBlockingViewportContent);

        document.head.removeChild(_viewportMeta);
    }
}

/**@
 * Reads the given value from the localStorage if supported by the browser. Fails gracefully by returning null
 * if no localStorage is available.
 *
 * @param name the name of the local storage variable
 * @returns the value in the local storage variable or null
 */
sirius.readLocalStore = function (name) {
    try {
        if (sirius.isDefined(window.localStorage)) {
            return window.localStorage.getItem(name);
        }
    } catch (e) {
        console.log('Cannot read local store', {name: name, error: e});
    }
    return null;
}

/**@
 * Writes the given value to the localStorage if supported by the browser. Fails gracefully by doing nothing,
 * if no localStorage is available.
 *
 * @param name the name of the local storage variable
 * @param value the value which should be stored in the local storage variable
 */
sirius.writeLocalStore = function (name, value) {
    if (!sirius.isDefined(value)) {
        value = '';
    }
    try {
        if (sirius.isDefined(window.localStorage)) {
            if (sirius.isEmpty(value)) {
                window.localStorage.removeItem(name);
            } else {
                window.localStorage.setItem(name, value);
            }
        }
    } catch (e) {
        console.log('Cannot write local store', {name: name, value: value, error: e});
    }
}

/**@
 * Checks if the given 'dragleave' event on the document is leaving the window.
 * This method exists because in safari the simple way of checking the relatedTarget does not work,
 * and we have to fall back to checking the coordinates to see if it is at the edge of the document.
 *
 * @param event the event to check
 */
sirius.isDragleaveEventLeavingWindow = function (event) {
    const isSafari = /^((?!chrome|android|edge).)*safari/i.test(navigator.userAgent);

    if (!isSafari && event.relatedTarget === null) {
        return true;
    }
    if (event.clientX >= window.innerWidth) {
        return true;
    }
    if (event.offsetX <= 0) {
        return true;
    }
    if (event.clientY >= window.innerHeight) {
        return true;
    }
    if (event.clientY <= 1) {
        return true;
    }
    return false;
}

/**@
 * Compares the two given objects for equality, allowing for nested objects.
 *
 * @param object1 the first object to compare
 * @param object2 the second object to compare
 * @returns {boolean} true if the objects are equal, false otherwise
 */
sirius.areObjectsDeeplyEqual = function (object1, object2) {
    const keys1 = Object.keys(object1);
    const keys2 = Object.keys(object2);

    if (keys1.length !== keys2.length) {
        return false;
    }

    // var is used here instead of const to keep the code compatible with IE11.
    for (var key of keys1) {
        const value1 = object1[key];
        const value2 = object2[key];
        const areObjects = sirius.isObject(value1) && sirius.isObject(value2);
        if (areObjects && !sirius.areObjectsDeeplyEqual(value1, value2)) {
            return false;
        }
        if (!areObjects && value1 !== value2) {
            return false;
        }
    }

    return true;
}

/**@
 * Checks if the given value is an object.
 *
 * @param object the value to check
 * @returns {boolean} true if the value is an object, false otherwise
 */
sirius.isObject = function (object) {
    return object != null && typeof object === 'object';
}
