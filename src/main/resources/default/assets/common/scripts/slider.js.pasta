(function (slider) {

    /**@
     * Initializes a slider.
     * <p>
     * Before calling this function, the slider already has to exist in the form of a html node containing all slides
     * as 'div' child nodes.
     *
     * @param target  css selector selecting the outer html node containing all slides as child nodes
     * @param options optional object specifying the behaviour of the slider (see constants for possible values):
     *                 - animation:  Time in ms between sliding (can be undefined for no animation)
     *                 - columns:    Number of columns to show/slide (defaults to 1, blending only works for one column)
     *                 - columnsSm:  Number of columns to show/slide on small screens
     *                 - columnsXs:  Number of columns to show/slide on tiny screens
     *                 - interrupt:  What actions interrupt the animation
     *                 - transition: Behaviour of the animation
     *                 - arrows:     Whether previous and next arrows should be shown and the location of them
     *                 - dots:       Whether dots (showing currently selected slide) should be shown
     */
    slider.initSlider = function (target, options) {
        const TRANSITION_BLEND = 'blend';
        const TRANSITION_SLIDE = 'slide';

        const DEFAULT_ANIMATION = 5000;

        options = options || {};
        options.columns = options.columns || 1;
        options.columnsSm = options.columnsSm || options.columns;
        options.columnsXs = options.columnsXs || options.columnsSm;
        options.animation = options.animation || DEFAULT_ANIMATION;
        options.arrows = !!options.arrows;
        options.dots = !!options.dots;
        options.interrupt = !!options.interrupt;

        if (options.columns <= 0) {
            console.warn('Invalid number of columns, defaulting to 1.');
            options.columns = 1;
        }
        if (options.columnsSm <= 0) {
            console.warn('Invalid number of columns on small screens, defaulting to 1.');
            options.columnsSm = 1;
        }
        if (options.columnsXs <= 0) {
            console.warn('Invalid number of columns on tiny screens, defaulting to 1.');
            options.columnsXs = 1;
        }
        if (options.animation <= 0) {
            console.warn('Invalid animation timing, defaulting to ' + (DEFAULT_ANIMATION / 1000) + ' seconds.');
            options.animation = DEFAULT_ANIMATION;
        }
        if (options.transition && options.transition !== TRANSITION_BLEND && options.transition !== TRANSITION_SLIDE) {
            console.warn('Invalid transition identifier, disabling transition.');
            options.transition = undefined;
        }

        if (options.columnsSm > options.columns) {
            console.warn('Number of columns on small screen must not be larger than the number of columns on normal screens. Resetting to ' + options.columns + '.');
            options.columnsSm = options.columns;
        }
        if (options.columnsXs > options.columnsSm) {
            console.warn('Number of columns on tiny screen must not be larger than the number of columns on small screens. Resetting to ' + options.columnsSm + '.');
            options.columnsXs = options.columnsSm;
        }

        // we remember the number of columns in a local variable, as the value may change according to the screen size,
        // assuming any of the values `options.columns`, `options.columnsSm`, or `options.columnsXs`
        let columns = options.columns;

        const _slider = document.querySelector(target);

        // obtain all the child nodes of the slider and mark them as "slider views"
        const _slides = Array.prototype.slice.call(_slider.childNodes).filter(function (node) {
            return node.tagName === 'DIV';
        });
        if (_slides.length < 2) {
            return;
        }
        _slides.forEach(function (_slide) {
            _slide.classList.add('sci-slider-view');
        });

        // create a wrapper node replacing (and later nesting) the original slider node
        const _wrapper = document.createElement('div');
        _wrapper.classList.add('sci-slider-wrapper');
        _slider.parentNode.replaceChild(_wrapper, _slider);

        // move classes from the original slider div to the wrapper, and add a marker to the slider itself
        while (_slider.classList.length > 0) {
            const clazz = _slider.classList.item(0);
            _wrapper.classList.add(clazz);
            _slider.classList.remove(clazz);
        }
        _slider.classList.add('sci-slider');

        // within the slider is a stack of up to two divs, the slider with the navigation arrows on top, and the dots
        // below
        const _top = document.createElement('div');
        _top.classList.add('sci-slider-top');
        _wrapper.appendChild(_top);

        if (options.arrows) {
            const _previousArrow = document.createElement('div');
            _previousArrow.classList.add('sci-slider-button');
            _previousArrow.classList.add('sci-slider-previous');
            const _previousIcon = document.createElement('a');
            _previousIcon.classList.add('sci-slider-previous-icon');
            _previousArrow.appendChild(_previousIcon);
            _top.appendChild(_previousArrow);
            _previousArrow.addEventListener('click', function (event) {
                stopAnimationThread();
                activatePreviousView();
                startAnimationThread();
            });
        }

        _top.appendChild(_slider);

        if (options.arrows) {
            const _nextArrow = document.createElement('div');
            _nextArrow.classList.add('sci-slider-button');
            _nextArrow.classList.add('sci-slider-next');
            const _nextIcon = document.createElement('a');
            _nextIcon.classList.add('sci-slider-next-icon');
            _nextArrow.appendChild(_nextIcon);
            _top.appendChild(_nextArrow);
            _nextArrow.addEventListener('click', function (event) {
                stopAnimationThread();
                activateNextView();
                startAnimationThread();
            });
        }

        let _dots = null;
        if (options.dots) {
            _dots = document.createElement('div');
            _dots.classList.add('sci-slider-dots');
            _wrapper.appendChild(_dots);
            _slides.forEach(function (_slide, index) {
                const _dot = document.createElement('a');
                _dot.textContent = '●';
                _dot.addEventListener('click', function (event) {
                    stopAnimationThread();
                    activateView(index, 1, true);
                    startAnimationThread();
                });
                _dot.classList.add('sci-slider-dot');
                _dots.appendChild(_dot);
            });
        }

        const resetAllSlides = function (callback) {
            _slides.forEach(function (_slide) {
                // set up the slide to fill the entire view within the slider, and not more
                _slide.style.position = 'absolute';
                _slide.style.left = '0';
                _slide.style.width = (_slider.offsetWidth / columns) + 'px';
                _slide.style.maxWidth = (_slider.offsetWidth / columns) + 'px';
                _slide.style.overflow = 'hidden';

                // the slide is limited to the width provided by the slider, but we want to center the content; we do
                // this by virtually scrolling the over-sized content such that it is centered
                _slide.scrollLeft = 0.5 * (_slide.scrollWidth - _slider.offsetWidth / columns);

                _slide.style.visibility = 'hidden';

                if (callback) {
                    callback(_slide.style);
                }
            });
        };

        let interruptedDueToMouseInteraction = false;
        if (options.interrupt) {
            _wrapper.addEventListener('mouseenter', function (event) {
                interruptedDueToMouseInteraction = true;
            });
            _wrapper.addEventListener('mouseleave', function (event) {
                interruptedDueToMouseInteraction = false;
            });
        }

        let previousIndex = 0;
        let currentIndex = 0;
        const activateViewWithoutAnimation = function () {
            // set all but the currently active view hidden
            resetAllSlides();
            _slides[currentIndex].style.visibility = 'visible';
        };
        const activateViewByBlending = function () {
            // set all but the previously and currently active view hidden
            resetAllSlides();
            _slides[previousIndex].style.visibility = 'visible';
            _slides[currentIndex].style.visibility = 'visible';

            // cross-blend the previous and current view, with the latter on top
            _slides[previousIndex].style.zIndex = '0';
            _slides[previousIndex].style.opacity = '0';
            _slides[currentIndex].style.zIndex = '1';
            _slides[currentIndex].style.opacity = '1';
        };
        const activateViewBySliding = function (direction) {
            // compute the initial and final positions of the current and previous slides
            const previousFrom = 0, currentTo = 0;
            let previousTo = 0, currentFrom = 0;
            if (direction > 0) {
                currentFrom = _slider.offsetWidth;
                previousTo = -_slides[previousIndex].offsetWidth;
            } else {
                currentFrom = -_slides[currentIndex].offsetWidth;
                previousTo = _slider.offsetWidth;
            }

            // without any animation, set the initial state
            resetAllSlides(function (style) {
                style.transition = '';
            });

            _slides[previousIndex].style.visibility = 'visible';
            _slides[previousIndex].style.left = previousFrom + 'px';
            _slides[previousIndex].style.zIndex = '0';

            _slides[currentIndex].style.visibility = 'visible';
            _slides[currentIndex].style.left = currentFrom + 'px';
            _slides[currentIndex].style.zIndex = '1';

            // after some time, to allow layouting to settle, trigger the actual animation
            setTimeout(function () {
                _slides[previousIndex].style.transition = 'left 1s ease';
                _slides[previousIndex].style.left = previousTo + 'px';

                _slides[currentIndex].style.transition = 'left 1s ease';
                _slides[currentIndex].style.left = currentTo + 'px';
            }, 50);
        };

        const activateView = function (index, direction, statically) {
            if (isNaN(index) || index < 0 || index >= _slides.length) {
                return;
            }
            if (typeof direction === 'undefined') {
                direction = 1;
            }

            previousIndex = currentIndex;
            currentIndex = index;
            statically |= previousIndex === currentIndex;

            _slides[previousIndex].classList.remove("sci-slider-view-active");
            _slides[currentIndex].classList.add("sci-slider-view-active");

            if (_dots) {
                _dots.childNodes.item(previousIndex).classList.remove("sci-slider-dot-active");
                _dots.childNodes.item(currentIndex).classList.add("sci-slider-dot-active");
            }

            if (!statically && options.transition === TRANSITION_BLEND) {
                activateViewByBlending();
            } else if (!statically && options.transition === TRANSITION_SLIDE) {
                activateViewBySliding(direction);
            } else {
                activateViewWithoutAnimation();
            }

            fixSliderHeight();
        };
        const activateNextView = function () {
            activateView((currentIndex + 1) % _slides.length, 1);
        };
        const activatePreviousView = function () {
            activateView((currentIndex - 1 + _slides.length) % _slides.length, -1);
        };

        const fixSliderHeight = function () {
            let containerHeight = 0;
            _slides.forEach(function (_slide) {
                containerHeight = Math.max(containerHeight, _slide.offsetHeight);
            });
            _slider.style.height = containerHeight + 'px';
        };

        const fixView = function () {
            if (window.innerWidth) {
                if (window.innerWidth < 992) {
                    columns = options.columnsXs;
                } else if (window.innerWidth < 1200) {
                    columns = options.columnsSm;
                } else {
                    columns = options.columns;
                }
            }

            fixSliderHeight();
            activateView(currentIndex, 1, true);
        };

        // upon resize, trigger a debounced graphics refresh
        let interruptedWhileChangingSize = false;
        let fixViewTimeout = null;
        let restartAnimationTimeout = null;
        window.addEventListener('resize', function (event) {
            // interrupt animation for at least a second, not to have it interfere with the resize
            interruptedWhileChangingSize = true;
            if (restartAnimationTimeout) {
                clearTimeout(restartAnimationTimeout);
            }
            restartAnimationTimeout = setTimeout(function () {
                interruptedWhileChangingSize = false;
            }, 1000);

            if (fixViewTimeout) {
                clearTimeout(fixViewTimeout);
            }
            fixViewTimeout = setTimeout(function () {
                fixView();
            }, 10);
        });

        const initAnimation = function () {
            if (options.transition === TRANSITION_BLEND) {
                // hide all views by setting them fully transparent and sorting them down on the stack
                resetAllSlides(function (style) {
                    style.opacity = '0';
                    style.zIndex = '0';
                    style.transition = 'opacity 1s ease';
                });

                _slides[0].style.opacity = '1';
                _slides[0].style.zIndex = '1';
                _slides[0].style.visibility = 'visible';
            } else {
                resetAllSlides();
                _slides[0].style.visibility = 'visible';
            }
        };

        let animationTimer = null;
        const startAnimationThread = function () {
            stopAnimationThread();

            animationTimer = setInterval(function () {
                if (!document.body.contains(_slider)) {
                    stopAnimationThread();
                    return;
                }
                fixView();
                if (options.animation && !interruptedDueToMouseInteraction && !interruptedWhileChangingSize) {
                    activateNextView();
                }
            }, options.animation);
        };
        const stopAnimationThread = function () {
            if (animationTimer) {
                clearInterval(animationTimer);
                animationTimer = null;
            }
        };

        initAnimation();
        fixSliderHeight();
        activateView(0, 1, true);
        startAnimationThread();

        setTimeout(fixView, 500);
    }
}(window.sirius.slider = window.sirius.slider || {}));
